# ===============================================
# CONFIGURAÇÕES DO SERVIDOR
# ===============================================
# Mesmo sendo um worker, Ã© bom ter uma porta definida para health checks.
# Usamos uma porta diferente para nÃ£o haver conflito com a API-1.
server.port=8081
spring.application.name=fipe-worker-api


# ===============================================================
# CONFIGURAÇÃO DO BANCO DE DADOS POSTGRESQL
# ===============================================================

# URL de conexão. Note que o host é 'postgres-db', o nome do serviço no docker-compose.yml
spring.datasource.url=jdbc:postgresql://postgres-db:5432/${POSTGRES_DB}

# Usuário e senha lidos diretamente das variáveis de ambiente do .env
spring.datasource.username=${POSTGRES_USER}
spring.datasource.password=${POSTGRES_PASSWORD}

# Driver JDBC do PostgreSQL
spring.datasource.driver-class-name=org.postgresql.Driver

# ===============================================================
# CONFIGURAÇÃO DO HIBERNATE (JPA)
# ===============================================================

# Estratégia de geração do banco. 'update' atualiza o schema sem apagar os dados.
spring.jpa.hibernate.ddl-auto=update

# Mostra no console os comandos SQL gerados pelo Hibernate. Ótimo para debug.
spring.jpa.show-sql=true

# Especifica o dialeto do PostgreSQL para o Hibernate se otimizar.
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect


# ===============================================
# CONFIGURAÇÕES DA FILA (RABBITMQ)
# ===============================================
# As configurações de host são as mesmas.
spring.rabbitmq.host=rabbitmq
spring.rabbitmq.port=5672
# Nome da fila que o worker vai consumir.
queue.fipe.brand.name=fipe-brand-queue